### 1. 참조 자료형(Reference type)과 기본 자료형(Primitive type)의 차이 정리.
    
**(1) 기본 타입(Primitive Type)**

- 기본 타입은 int, double 등과 같이 값이 직접 저장되는 데이터 타입이다.
- 종류로는 byte, short, char, int, float, double, boolean이 있다.
- 기본 타입은 크기가 고정되어 있으며, 일반적으로 메서드의 지역 변수로 선언될 경우 Stack에 저장되나, 클래스 필드(멤버 변수)로 선언되면 Heap에 저장된다.
- 지역 변수는 메서드 종료 시 스택에서 제거되고, Heap에 저장된 기본 타입 필드는 객체와 함께 관리된다.

**(2) 참조 타입(Reference Type)**

- 참조 타입은 new 키워드를 이용해 객체를 생성하고, 생성된 데이터의 메모리 주소를 참조하는 타입이다.
- 종류로는 class, array, interface, enum 등이 있다.
- 참조 타입 데이터는 크기가 고정적일 수도 있지만 동적일 수도 있으며, Heap 영역에 저장된다.
- 더 이상 참조되지 않는 객체는 JVM의 가비지 컬렉션에 의해 제거된다.


### 2. 기본 자료형 8가지를 나열하고 각 타입의 특징 정리.
    
| 타입 | 크기 | 값의 범위 | 특징 |
| --- | --- | --- | ---- |
| **byte** | 8비트 | -128 ~ 127 | 메모리 절약, 데이터 스트림 처리 |
| **short** | 16비트 | -32,768 ~ 32,767 | 메모리 절약, 잘 사용되지 않음 |
| **int** | 32비트 | -2,147,483,648 ~ 2,147,483,647 | 기본 정수형 |
| **long** | 64비트 | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 큰 정수 |
| **float** | 32비트 | ±3.4x10⁻³⁸ ~ ±3.4x10³⁸ | 부동소수점, 낮은 정밀도 |
| **double** | 64비트 | ±1.7x10⁻³⁰⁸ ~ ±1.7x10³⁰⁸ | 높은 정밀도의 부동소수점 |
| **char** | 16비트 | 0 ~ 65,535 (유니코드) | 단일 문자 |
| **boolean** | 1비트 | `true`, `false` | 논리형 |


### 3. 형변환이란 무엇이고 왜 하는지 정리.
- 자바에서는 서로 다른 데이터 타입 간의 연산이나 대입이 필요한 경우 형변환을 통해 타입을 일치시킨다.
- 형변환으로 타입 불일치 해결, 데이터 손실 방지 또는 메모리의 효율성을 얻는다
- ***byte -> short -> char -> int -> long -> float -> double*** 순으로는 자동 형변환 (Implicit Casting)이 가능하다. JVM이 자동으로 처리한다.
- 명시적 형변환 (Explicit Casting)은 서로 호환되지 않는 타입 간 변환으로 데이터 손실이 발생할 수 있다.


### 8. 생성자는 무엇을 하는 데 사용하는 것이며, 별도로 만들지 않아도 자동으로 생성되는 생성자에 대해서 정리.

```java
public class ReferenceString {

    public ReferenceString() {}   // 생성자

    public static void main(String args[]) {
        ReferenceString reference = new ReferenceString();   // 객체 생성

    }
}
```
**생성자의 역할**

1. **객체 초기화**: 객체가 생성될 때 필드(멤버 변수)를 초기화하거나 특정 동작을 수행.
2. **클래스의 상태 설정**: 특정 값을 인자로 받아 필드를 설정.
3. **특별한 동작 수행**: 객체 생성 시 필요한 리소스 할당 또는 초기화.

개발자가 생성자를 정의하지 않으면 **컴파일러가 기본 생성자(Default Constructor)**를 자동으로 생성한다.


### 9. Overloading은 무엇인지, public void setData(int a)라는 메소드를 원하는 대로 Overloading.

- **오버로딩(Overloading)**은 **메서드 이름은 동일하지만, 매개변수의 개수나 타입이 다르게 정의**하여 여러 버전의 메서드를 제공하는 기능이다.

```java
//1. 매개변수 타입 변경
public void setData(String a) {
    System.out.println("String value: " + a);
}

//2. 매개변수 개수 변경
public void setData(int a, int b) {
    System.out.println("Two integers: " + a + ", " + b);
}
```


### 10. 패키지를 선언하는 위치와 이름을 지정할 때의 유의점 정리.

- 패키지 선언은 **소스 파일의 최상단에 작성**
- import 문이나 클래스 선언 전에 위치

**네이밍 규칙**

1. 이름은 **소문자로 작성**하며, **도메인 이름을 역순으로 사용**하여 고유성을 확보.
2. **예약어는 사용 불가**, **명확한 이름**으로 패키지의 역할을 표현.
3. **파일 경로와 패키지 이름을 일치**시키고, 기본 패키지 사용은 지양


### 11. 다른 패키지에 선언된 클래스를 사용하기 위한 import는 어디에 선언해야 하며, static import는 무엇인지 정리.

- `import` 문은 **패키지 선언 바로 아래, 클래스 선언 전에** 위치.
- **static import**: 다른 클래스의 static 멤버를 클래스 이름 없이 사용하기 위해 선언.


### 12. 클래스란? 다음의 단어들이 포함되는 문장을 작성 & 주어진 단어의 의미도 같이 정리(속성, 상태)

- 클래스는 객체를 생성하기 위한 설계도이며, 속성(데이터)과 행위(메서드)를 정의.
- **속성**: 객체가 가지는 데이터나 특징.
- **상태**: 객체의 속성 값들의 조합으로 표현되는 현재 모습.
- 클래스는 객체의 상태를 정의하고 이를 조작하는 기능을 제공


### 13. 인터페이스, abstract 클래스, 클래스, Enum 클래스가 있는데 각각의 특징 및 차이점 정리.
    
| 특징 | 클래스 | 추상 클래스 | 인터페이스 | 열거형 클래스 |
| --- | --- | --- | --- | --- |
| **목적** | 객체 생성 | 공통 기능 + 하위 클래스 구현 강제 | 계약 정의 | 제한된 상수 값 정의 |
| **객체 생성 가능** | 가능 | 불가능 | 불가능 | 불가능 |
| **상속** | 단일 상속 | 단일 상속 | 다중 구현 가능 | 불가능 (암묵적 final) |
| **메서드** | 구현 메서드만 | 구현 + 추상 메서드 | (Java 8 이후) 기본/정적 메서드 포함 | 구현된 메서드 포함 가능 |
| **필드** | 일반 필드 가능 | 일반 필드 가능 | `public static final` (상수)만 | 내부 변수 및 상수 |
| **키워드** | `class` | `abstract class` | `interface` | `enum` |


### 14. instanceof라는 연산자의 용도 정리.

- 다형성 객체의 실제 타입 확인
- 캐스팅 전 안전성 검증
- 인터페이스 구현 여부 확인


### 15. 어떤 클래스를 상속받아 확장을 하면, 부모 클래스의 어떤 것들을 사용할 수 있는지 정리.

- **접근 제어자(access modifier)**에 따라 상속 시 사용 가능한 멤버(필드, 메서드)가 다르다.

**접근 제어자에 따른 사용 가능 여부**

| 접근 제어자 | 같은 클래스 | 같은 패키지 | 하위 클래스 | 외부 클래스 |
| --- | --- | --- | --- | --- |
| **`public`** | O | O | O | O |
| **`protected`** | O | O | O | X |
| `default` | O | O | X | X |
| **`private`** | O | X | X | X |

**부모 클래스와 상속의 주요 동작**

1. **super 키워드 사용**:
    - 부모 클래스의 필드와 메서드에 접근.
    - 부모 클래스의 생성자를 호출.
    
    ```java
    class Parent {
        int value = 10;
    
        void display() {
            System.out.println("Parent display method");
        }
    }
    
    class Child extends Parent {
        int value = 20;
    
        void show() {
            System.out.println("Child value: " + value); // 자식 클래스 필드
            System.out.println("Parent value: " + super.value); // 부모 클래스 필드
        }
    
        @Override
        void display() {
            super.display(); // 부모 클래스 메서드 호출
            System.out.println("Child display method");
        }
    }
    
    ```
    
2. **final 클래스와 메서드**:
    - **`final` 클래스**: 상속 불가.
    - **`final` 메서드**: 하위 클래스에서 재정의 불가.
    
    ```java
    final class Parent {} // 이 클래스는 상속 불가
    ```
    
- **사용 가능**:
    - `public` 및 `protected` 멤버.
    - `default` 멤버(같은 패키지인 경우).
- **사용 불가**:
    - `private` 멤버.
    - 부모 클래스의 생성자(직접 상속되지 않음).
- **추가 고려 사항**:
    - `final` 메서드는 오버라이딩 불가.
    - `static` 메서드는 오버라이딩이 아닌 숨김(hiding) 발생.


### 16. 변수를 final로 선언하는 것이 어떤 의미가 있는지 정리.

- `final` 키워드는 Java에서 변수를 **한 번만 초기화**할 수 있도록 제한하는 **수정자**.
- 변수의 **값 변경을 방지**하기 위해 사용.
- `static final`은 **클래스 상수**를 정의할 때 사용.


### 17. 클래스를 final로 선언하는 것이 어떤 의미가 있는지 정리.

- 클래스를 `final`로 선언하면 **상속을 금지**
- 다른 클래스에 의해 확장될 수 없다.(**재사용성**이 제한)
- 해당 클래스의 객체를 생성할 때 **성능 최적화**를 할 수 있어 실행 속도가 빠르다.
- 보안이 중요한 클래스에서 기능을 수정하는 것을 막을 수 있다.


### 18. 변수를 static으로 선언하는 것이 어떤 의미가 있는지 정리.

- **`static` 변수**는 **클래스 수준에서 공유되는 변수**로, **모든 객체에서 동일한 값**을 가진다.
- 객체를 생성하지 않고도 **클래스명으로 직접 접근**할 수 있으며, 여러 인스턴스에서 **같은 데이터를 사용**할 때 유용하다.
- **단점**은 **상태를 공유**하기 때문에, 객체 간에 **예기치 않은 상호작용**이 발생할 수 있다.

**`static` 변수와 인스턴스 변수의 차이**

| 구분 | `static` 변수 | 인스턴스 변수 |
| --- | --- | --- |
| **소속** | 클래스에 소속 | 객체에 소속 |
| **공유 여부** | 모든 객체가 공유 | 각 객체가 독립적으로 가짐 |
| **초기화** | 클래스가 로드될 때 초기화 | 객체 생성 시 초기화 |
| **접근 방법** | 클래스명으로 직접 접근 (`ClassName.variable`) | 객체를 통해 접근 (`objectName.variable`) |


### 19. 메소드를 static으로 선언하는 것이 어떤 의미가 있는지 정리.

- **`static` 메소드**는 **객체를 생성하지 않고** **클래스명으로 직접 호출**할 수 있는 메소드.
- **인스턴스와 관계없이** 동작하며, **객체 상태**와 무관한 작업을 수행하는 데 적합.
- **단점**으로는 인스턴스 변수나 메소드에 접근할 수 없으며, 객체 지향 설계에서의 유연성은 떨어짐
- 주로 **유틸리티 메소드**나 **싱글턴 패턴** 구현에 사용

**`static` 메소드와 인스턴스 메소드 차이**

| 구분 | `static` 메소드 | 인스턴스 메소드 |
| --- | --- | --- |
| **소속** | 클래스에 소속 | 객체(인스턴스)에 소속 |
| **호출 방법** | 클래스명으로 호출 (`ClassName.method()`) | 객체를 통해 호출 (`object.method()`) |
| **인스턴스 변수 접근** | 불가능 | 가능 |
| **상속** | 오버라이딩 불가능 | 오버라이딩 가능 |
| **용도** | 객체 상태와 관계없는 기능, 유틸리티 메소드 | 객체의 상태를 변경하거나 동작하는 메소드 |


### 20. try-catch-finally 블록은 왜 사용하고 각각의 블록이 어떤 용도로 사용되는지 정리.
- **`try-catch-finally`** 블록은 예외를 처리하고, 예외 발생 시 프로그램이 종료되지 않도록 하며, 예외가 발생하더라도 **자원 해제**와 같은 **후속 작업**을 처리하는 데 사용

```java
import java.io.FileReader;
import java.io.IOException;

public class Example {

    public static void main(String[] args) {
        FileReader file = null;

        try {
            file = new FileReader("example.txt");  // 파일 열기
            // 파일을 읽는 코드가 들어갈 수 있음
            System.out.println("파일을 성공적으로 읽었습니다.");
        } catch (IOException e) {
            System.out.println("파일 읽기 중 오류 발생: " + e.getMessage());
        } finally {
            try {
                if (file != null) {
                    file.close();  // 파일을 닫는 작업
                    System.out.println("파일이 닫혔습니다.");
                }
            } catch (IOException e) {
                System.out.println("파일 닫기 중 오류 발생: " + e.getMessage());
            }
        }
    }
}
```

- **`try`**:
    - `try` 블록에서 **파일 열기** 작업을 시도하고, 파일을 읽는다.
    - 만약 파일이 없거나 읽을 수 없으면 `IOException` 예외가 발생한다.
- **`catch`**:
    - 예외가 발생하면, 해당 예외를 **처리**하여 프로그램이 중단되지 않도록 한다. 메시지를 출력하거나, 예외를 적절히 처리하는 로직을 넣는다.
- **`finally`**:
    - 예외 발생 여부와 관계없이, **파일을 닫는 작업**을 진행한다.
    - 예외가 발생하더라도, `finally` 블록에서 **자원 해제**나 **정리 작업**을 할 수 있다.

- 자원 관리를 위해 도입된 **`try-with-resources` 구문**도 사용한다. `AutoCloseable` 인터페이스를 구현한 객체들을 `try` 구문에 포함시키면 **자동으로 자원을 닫을 수** 있어 자원을 명시적으로 닫을 필요가 없다.
