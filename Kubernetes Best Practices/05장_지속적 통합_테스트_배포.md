이번 장에서는 애플리케이션을 쿠버네티스에 배포하기 위한 CI/CD(지속적 통합/지속적 배포) 파이프라인 구축 방법을 다룹니다. 잘 통합된 파이프라인은 배포 자동화로 안정성과 속도를 개선합니다. 수동 배포의 오류와 설정 표류 문제를 해결하기 위해 자동화된 프로세스를 구현하는 것이 목표입니다.

**주제**

1. 버전 관리
2. CI
3. 테스트
4. 이미지 태깅
5. CD
6. 배포 전략
7. 배포 테스트
8. 카오스 실험
- **파이프라인 예제**
    1. 깃 리포지터리에 코드 변경 사항 푸시
    2. 애플리케이션 코드 빌드
    3. 코드 테스트
    4. 테스트 성공 시 컨테이너 이미지 빌드
    5. 이미지 컨테이너 레지스트리에 푸시
    6. 쿠버네티스에 애플리케이션 배포
    7. 배포 애플리케이션 테스트
    8. 디플로이먼트 롤링 업그레이드 실행

이 장은 자동화된 배포를 통해 오류를 줄이고 배포 속도를 향상시키는 방법에 중점을 둡니다.

## 5.1 버전 관리

- summary : 쿠버네티스 매니페스트와 헬름 차트로 코드와 설정을 통합해 개발자와 운영팀 간 협업과 신뢰를 강화합니다.
    - 모든 CI/CD 파이프라인은 애플리케이션 실행 이력과 설정 코드 변경을 관리하는 버전 관리
    - 깃은 소스 버전 관리 플랫폼으로서 업계 표준
    - 모든 깃 리포지터리에는 운영 코드가 포함된 마스터 브랜치가 존재
    - 기능과 개발을 위한 브랜치도 별도로 존재하며 나중에 마스터 브랜치로 병합
    - 브랜치 전략을 세우는 방법에는 여러 가지가 있으며 조직 구조와 업무에 따라 다름
    - 쿠버네티스 매니페스트 또는 헬름 차트에는 애플리케이션 코드와 설정 코드가 모두 포함
    - 이는 소통과 협업의 데브옵스 원칙을 정립하는 데 도움
    - 애플리케이션 개발자와 운영 엔지니어가 단일 스토리지에서 공동의 작업을 수행하게 되면, 애플리케이션을 운영에 전달하는 팀에 대한 신뢰도 향상

## 5.2 지속적 통합

- summary : 데브옵스 문화 확산으로 운영팀도 애플리케이션 코드와 개발 워크플로를 이해하게 되었으며, 대표적인 CI 도구로 **Jenkins**가 있습니다.
    - CI는 코드 변경을 버전 관리 리포지터리에 지속적으로 통합하는 과정
    - 코드를 리포지터리에 커밋할 때는 큰 코드 변경을 가끔씩 하는 것보다 작은 코드 변경을 자주 하는 것이 나음
    - 코드 변경이 커밋될 때마다 빌드가 실행
    - 문제가 발생했을 때 빠른 피드백
    - 전통적으로는 개발자만의 역할이었지만 최근 기업들이 데브옵스 문화를 점차 수용하면서 운영 팀 역시 애플리케이션 코드와 소프트웨어 개발 워크플로를 알아감
    - CI의 대표적인 제품으로는 Jenkins가 있음

## 5.3 테스트

- summary : 인프라와 애플리케이션의 자동 운영과 배포를 위해 모든 코드베이스를 자동으로 테스트하는 방안을 찾아야 합니다. 예를 들어 차트의 잠재적인 문제를 해결하는 헬름이 있다.
    
    파이프라인에서 테스트를 실행하는 이유는 코드 변경으로 빌드가 실패할 때 빠르게 피드백을 받기 위해서입니다. 사용 중인 언어에 따라 테스트 프레임워크가 결정됩니다. 예를 들어 Go 애플리케이션은 코드베이스에 대한 단위 테스트를 위해 go test를 사용합니다. 폭넓은 테스트 집합이 있으면 나쁜 코드가 운영 환경에 배포되는 것을 막을 수 있습니다. 그러려면 테스트가 실패할 때 빌드도 반드시 실패해야 합니다. 또한 컨테이너 이미지가 빌드되어 레지스트리에 푸시되면 안 됩니다.
    
    또다시 이런 의문이 들지 모릅니다. '테스트를 만드는 것은 개발자의 역할이 아닌가요?' 인프라와 애플리케이션을 자동으로 운영하고 배포하려면 모든 코드베이스를 자동으로 테스트하는 방안을 찾아야 합니다. 
    
    예를 들어, 우리는 2장에서 쿠버네티스 애플리케이션을 패키지하기 위해 헬름을 사용하는 방법을 다뤘습니다. 헬름에는 helm lint라는 도구가 있는데, 차트의 잠재적인 문제를 조사하기 위해 일련의 테스트를 수행합니다. 파이프라인에는 이외에도 실행되어야 할 많은 다른 테스트가 있습니다. 애플리케이션 단위 테스트와 같은 일부는 개발자의 책임이지만 스모크 테스트와 같은 일부는 공동의 협력이 필요합니다. 코드베이스를 테스트하여 운영에 전달하는 것은 팀의 노력이 필요하며 점진적으로 구현해야 합니다.
    

## 5.4 컨테이너 빌드

이미지 빌드시 이미지가 작을수록 속도와 보안 면에서 장점을 가집니다. 작은 이미지를 위한 빌드 방법에는 세가지 전략이 있습니다. 하지만 각 전략에는 트레이드 오프가 존재합니다.

- 다중 단계 빌드
- 배포판이 없는 기본 이미지
- 최적화된 기반 이미지
1. **다중 단계 빌드**
    - 애플리케이션 실행에 불필요한 의존성을 제거해 최적화된 이미지를 생성.
    - Go와 같은 언어에서 정적 바이너리만 포함하는 이미지를 하나의 Dockerfile로 빌드 가능.
2. **배포판이 없는 기본 이미지**
    - 불필요한 바이너리와 shell 제거로 이미지 크기 감소 및 보안 강화.
    - 단, shell과 디버깅 도구가 없어 디버깅에 어려움이 있음.
3. **최적화된 기반 이미지**
    - OS 계층에서 불필요한 요소를 제거한 가벼운 이미지 사용. 예: Alpine Linux(10MB)나 Debian.
    - 이미지 최적화는 컨테이너 효율성과 보안을 높이는 데 중요하지만 종종 간과됨.
- 본문
    
    ### 1. 다중 단계 빌드
    
    애플리케이션을 실행할 때 불필요한 의존 관계를 제거합니다. 예를 들어 Go 언어를 사용한다면 정적 바이너리를 빌드할 때 사용되는 모든 도구가 필요하지 않습니다. 다중 단계 빌드를 이용하면 하나의 도커파일로 애플리케이션 실행에 필요한 정적 바이너리만 포함하는 최적 이미지를 빌드할 수 있습니다.
    
    ### 2. 배포판이 없는 기본 이미지
    
    불필요한 바이너리와 shell과 같은 것은 이미지에서 제거합니다. 이미지의 크기를 눈에 띄게 줄일 수 있으며 보안을 강화할 수 있습니다. 배포판이 없는(distroless) 이미지는 shell이 없으므로 이미지에 디버거를 붙일 수 없다는 단점을 가집니다. 애플리케이션을 디버그할 때는 상당히 고통스럽습니다.
    패키지 관리자, shell, 기타 일반적인 OS 패키지가 없기 때문에 일반적인 OS에서 친숙한 디버그 도구를 사용할 수 없습니다.
    
    ### 3. 최적화된 기반 이미지
    
    OS 계층에서 불필요한 것을 제거하고 군살을 뺀 이미지입니다. 예를 들어 Alpine Linux는 10MB의 기반 이미지와 로컬 개발을 위한 디버거를 제공합니다. Debian과 같은 리눅스 배포판 역시 최적화된 기반 이미지를 기본으로 제공합니다. 기반 이미지는 개발할 때 필요한 기능을 제공하면서 이미지 크기 최적화와 보안 위험도 낮추기 때문에 훌륭한 선택지입니다.
    
    이미지를 최적화하는 것은 굉장히 중요하지만 종종 간과되곤 합니다. 승인된 OS만 사용해야 하는 회사의 표준 때문일 수도 있습니다. 하지만 최적화를 통해 컨테이너의 가치를 극대화할 수 있습니다.
    
    컨테이너 환경에서 운영과 개발에 더욱 능숙해지면 배포판이 없는 이미지에 익숙해질 것입니다.
    

## 5.5 컨테이너 이미지 태그

- **Docker 이미지 빌드 및 태그 전략 중요성**
    
    CI 파이프라인에서 도커 이미지를 빌드하고 배포 시, 배포 이미지의 버전을 명확히 구분할 태그 전략이 필요.
    
- **`latest` 태그 사용 지양**
    
    `latest`는 버전 정보가 없어 코드 변경 이력을 파악하기 어렵기 때문.
    
- **고유 태그 필수**
    
    모든 이미지는 고유한 태그를 가져야 코드 변경 및 빌드를 추적 가능.
    
- **효과적인 태그 전략 필요**
    
    적절한 전략을 통해 코드 변경 및 빌드 이력을 쉽게 관리 가능.
    
- 태그 전략
    1. **BuildID**
        - CI 빌드 시 생성된 BuildID를 태그에 사용해 이미지의 빌드 출처를 파악 가능.
    2. **빌드 시스템-BuildID**
        - 여러 빌드 시스템을 구분하기 위해 BuildID에 빌드 시스템 정보를 추가.
    3. **깃 해시** 
        - 커밋 시 생성된 깃 해시를 태그에 포함해 생성된 커밋 정보를 확인 가능.
    4. **깃 해시-BuildID** 
        - 커밋과 BuildID를 조합해 상세한 이미지 출처를 제공
        - 긴 태그 길이에 주의 필요.

- 본문
    
    CI 파이프라인의 또 다른 단계는 도커 이미지를 빌드하여 배포할 이미지 산출물을 만드는 것입니다. 여기서 운영에 배포한 이미지의 버전을 쉽게 분별하기 위한 이미지 태그 전략을 세우는 것이 중요합니다. 가장 중요한 것 중 하나는 latest를 이미지 태그로 사용하지 않는 것입니다. 이것은 버전이 아니므로 롤아웃 이미지의 어떤 코드가 변경된 건지 파악할 수 없습니다. CI 파이프라인에서 빌드된 모든 이미지는 고유한 태그를 가져야 합니다.
    
    CI 파이프라인에서 이미지를 태그할 때 효과적인 여러 전략이 있습니다. 다음과 같은 전략을 이용하면 코드 변경 및 빌드를 쉽게 파악할 수 있습니다.
    

## 5.6 지속적 배포

변경 사항을 자동으로 운영에 배포합니다. 컨테이너 이미지가 개발, 스테이지, 운영으로 옮겨갈 수 있도록 불변 객체가 된다. CD에 집중하기 전에 먼저 견고한 CI 파이프라인을 구축해야 합니다. 초기에 견고한 테스트 집합을 갖춰야 잘못된 롤아웃을 막습니다.

- **설정 표류** : 스테이지에서 잘 동작하던 디플로이먼트가 운영으로 넘어간 후 배포에 실패하는 경우가 많습니다.

## 5.7 배포 전략

애플리케이션의 새로운 버전을 롤아웃하기 위한 여러가지 전략을 제공합니다. 

- 롤링 업데이트
    - 
- 블루/그린 배포
    - 
- 카나리 배포

다운타임 없이 업데이트 가능

- 상세
    
    쿠버네티스에 내장되어 있는 롤링 업데이트를 사용하면 현재 실행 중인 애플리케이션을 다운타임 없이 업데이트할 수 있습니다. 예를 들어 현재 frontend:v1으로 실행 중인 프런트엔드 앱을 frontend:v2로 업데이트한 경우 쿠버네티스는 롤링 방식으로 레플리카를 frontend:v2로 업데이트합니다. 
    
    ![20241126_180219_284.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/bf8b5dbc-826d-4e7f-8b31-80262575587f/a431dba4-f1f2-4f4d-b9d1-e41c4a115f4c/20241126_180219_284.jpg)
    
    디플로이먼트 객체를 사용하면한 번에 업데이트할 최대 레플리카 수와 사용할 수 없는 최대파드 수를 롤아웃 과정에서 설정할 수 있습니다. 다음 매니페스트는 롤링 업데이트 전략을 설정하는 방법의 예입니다.
    
    ```yaml
    kind: Deployment
    apiVersion: v1
    metadata:
      name: frontend
    spec:
      replicas: 3
      template:
        spec:
          containers:
          - name: frontend
            image: brendanburns/frontend:v1
      strategy:
        type: RollingUpdate
        rollingUpdate:
          maxSurge: 1 # 한 번에 업데이트할 최대 레플리카 수
          maxUnavailable: 1 # 롤아웃 중간에 가용하지 않는 최대 레플리카 수
    ```
    
    롤링 업데이트를 사용하면 클라이언트와의 연결이 끊어질 수 있으므로 주의해야 합니다. 이를 해결하기 위해 준비성 프로브(Readiness Probe)와 preStop 라이프사이클 훅을 사용할 수 있습니다. 준비성 프로브는 배포된 새로운 버전이 트래픽을 수용할 준비가 되었는지 확인하고 preStop 훅은 현재 배포된 애플리케이션의 커넥션을 드레인합니다. 이 훅은 컨테이너가 종료되기 전에 동기 방식으로 호출되므로 마지막 종료 신호를 받기 전에 완료되어야만 합니다. 다음 예제는 준비성 프로브와 라이프사이클 훅을 구현한 예입니다.
    
    ```yaml
    kind: Deployment
    apiversion: V1
    metadata:
    	name: frontend
    spec:
    	replicas: 3
    	template:
    		spec:
    			containers:
    			- name: frontend
    				image: brendanburns/frontend:v1
    				livenessprobe:
    				  # ...
    				readinessprobe:
    					httpGet:
    						path: /readiness # 프로브 엔드포인트
    						port: 8888
    				lifecycle:
    					prestop:
    						exec:
    							command: ["/usr/sbin/nginx", "-s", "quit"]
    strategy:
    	# ...
    ```
    
    이 예제에서 preStop 라이프사이클 훅은 정상적으로 NGINX를 종료하는 반면, SIGTERM은 빠르게 강제 종료 작업을 수행합니다.
    
    롤링 업데이트의 또 다른 문제는 롤오버 중간에 두 가지 버전의 애플리케이션이 동시에 실행된다는 것입니다. 따라서 데이터베이스 스키마는 애플리케이션의 두 가지 버전 모두를 지원해야 합니다. 여기서 스키마에 새로운 버전에 필요한 컬럼을 추가하는 기능 플래그 전략을 사용할 수도 있습니다. 롤링 업데이트가 완료된 이후에는 불필요한 컬럼을 삭제할 수 있습니다.
    
    또한 우리는 디플로이먼트 매니페스트에 준비성과 생명성 프로브를 정의했습니다. 준비성 프로브는 엔드포인트인 서비스 뒤에 트래픽을 배치하기 전에 애플리케이션이 트래픽을 지원할 준비가 되었는지를 확인합니다. 생명성 프로브는 애플리케이션이 정상적으로 실행 중인지 확인하며 만약 생명성 프로브에 실패할 경우 파드를 재시작합니다. 쿠버네티스는 오류 때문에 파드가 종료되었을 때만 자동으로 재시작합니다. 데드락에 걸려 종료되지 않은 파드도 생명성 프로브를 이용하여 엔드포인트를 점검하고 재시작할 수 있습니다.
    
    블루/그린 배포를 사용해 예측 가능한 방식으로 애플리케이션을 릴리스할 수 있습니다. 블루/그린 배포는 트래픽이 새로운 환경으로 전환되는 시점을 조절할 수 있으므로 새 버전의 애플리케이션 롤아웃을 효과적으로 통제할 수 있습니다. 대신 기존 환경과 새로운 환경을 동시에 배포할 만큼 충분한 용량이 필요합니다. 이 유형의 배포는 이전 버전으로 쉽게 전환되는 등 많은 장점을 가집니다. 그렇지만 몇 가지 주의할 사항이 있습니다.
    
    - 데이터베이스 마이그레이션이 어려울 수 있습니다. 진행 중인 트랜잭션과 스키마 업데이트의 호환성을 고려해야 하기 때문입니다.
    - 두 환경을 우연히 삭제할 위험이 있습니다.
    - 두 환경을 위한 추기적인 용랑이 필요합니다.
    - 하이브리드 배포의 경우 레거시 앱에서 발생하는 문제를 해결해야 합니다.
    
    [그림 5-2]는 블루/그린 배포를 보여줍니다.
    
    ![20241126_180253_351.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/bf8b5dbc-826d-4e7f-8b31-80262575587f/b439056d-5280-460e-a1b2-7dbd84ed804b/20241126_180253_351.jpg)
    
    카나리 배포는 블루/그린 배포와 상당히 유사하지만 신규 배포로 트래픽을 전환하는 것에 대해 다양한 통제권을 제공합니다. 최신 인그레스 구현은 신규 배포로 전달할 트래픽의 비율을 정할 수 있는 기능이 있습니다. 배포 전략 구현에 필요한 여러 기능을 제공하는 이스티오, 링커드, 해시코프의 콘술과 같은 서비스 메시(Service Mesh) 기술을 구현할 수 있습니다.
    
    카나리 배포에서는 일부 사용자에게만 새로운 기능을 테스트할 수도 있습니다. 예를 들어 새로운 버전의 애플리케이션을 전체 사용자의 10%에게만 우선 롤아웃해서 테스트할 수 있습니다. 적은 수의 사용자에게만 먼저 노출하여, 잘못 배포하거나 기능이 동작하지 않는 위험성을 줄이는 것입니다. 문제가 없다면 더 많은 트래픽 비율을 새로운 애플리케이션으로 이동시킵니다. 특정 리전의 사용자나 특정 프로필을 가진 사용자만을 대상으로 카나리 배포를 할 수 있는 고급 기술도 있습니다. 사용자는 새로운 기능을 테스트하고 있다는 것을 모르기 때문에 이러한 배포를 흔히 A/B 또는 다크 릴리스(Dark Release)라고 부릅니다.
    
    카나리 배포에는.블루/ 그린 배포의 주의 사항을 포함하여 아래와 같은 추가 고려 사항이 있습
    니다. 
    
    - 일부 사용자에게만 트래픽을 전환하는 기능
    - 신규 배포 상태와 비교하기 위한 안정된 상태에 대한 확고한 지식
    - 신규 배포가 '좋은'또는 '나쁜' 상태인지 알수 있는 매트릭
    
    [그림 5-3]은 카나리 배포의 예시입니다.
    
    ![20241126_180258_560.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/bf8b5dbc-826d-4e7f-8b31-80262575587f/081b70aa-6421-4ec6-a3ed-3f722f333c83/20241126_180258_560.jpg)
    
    NOTE_카나리 배포는 동시에 여러 버전의 애플리케이션을 실행할 때 어려움을 겪습니다. 예를 들어 데이터베이스 스키마는 두 버전의 애플리케이션을 동시에 지원해야 합니다. 그래서 이 전락을 사용할 때는 의존된 서비스를 다루는 방법과 여러 비전을 실행히는 법을 제대로 파악해야 합니다. 이는 견고한 AP 계약을 체결하고 데이터 서비스가 동시에 배포된 여러 비전을 지원하도록 보장하는 것을 포함합니다.
    

## 5.8 운영에서 테스트

- summary
    
    운영 환경에서 테스트를 수행하면 애플리케이션의 탄력성, 확장성, UX에 대한 신뢰를 쌓을 수 있습니다. 운영 테스트는 도전적이며 위험하지만 시스템의 안정성을 위해 시도해볼 가치가 있습니다. 시도하기 전에 미리 해결해야 할 중요한 것들이 있습니다. 운영 테스트의 효과를 파악할 수 있는 심층적인 관찰 전략을 마련하는 것입니다. 최종 사용자의 UX에 영향을 미치는 메트릭을 관찰할 수 없다면, 시스템의 복원력을 향상시키기 위한 명확한 지표가 없는 것입니다. 또한 시스템이 구성한 점으로부터의 자동 복구를 위한 높은 수준의 자동화가 필요합니다.
    
    위험을 줄이면서 시스템을 효과적으로 테스트하려면 많은 도구를 구현해야 합니다. 일부는 이미 이전 장에서 설명했지만 분산 추적(Distributed Tracing), 인스트루멘테이션(Instrumentation), 카오스 엔지니어링(Chaos Engineering), 트래픽 섀도잉(Traffic Shadow)이 필요합니다. 이미 언급한 도구는 아래와 같습니다.
    
    - 카나리 배포
    - A/B 테스트
    - 트래픽 전환
    - 기능 플래그
    
    카오스 엔지니어링은 넷플릭스(Netflix)에서 개발했습니다. 실제 생산 시스템에 실험을 배치해 그 시스템 내의 취약점을 발견하는 것입니다. 통제된 실험 환경에서 시스템의 동작을 관찰하고 파악할 수 있습니다. 다음은 '결전의 날'에 실험을 수행하기 전 구현하고자 하는 내용입니다.
    
    - 가설을 세우고 안정된 상태를 파악합니다.
    - 시스템에 영향을 미치는 현업의 다양한 이벤트를 모읍니다.
    - 통제 그룹을 구축하고 안정된 상태와 비교하는 실험을 합니다.
    - 실험을 수행해 가설을 검증합니다.
    
    실험을 수행할 때 '폭발 반경(blast radius)', 다시 말하자면 생길 수 있는 문제의 범위를 최소화해야 합니다. 또한 실험 수행에는 극심한 노동력이 필요하므로 자동화해야 합니다.
    
    여기서 '스테이지에서 테스트하면 안 되나요?'라는 의문을 가질 수도 있습니다. 이는 다음과 같은 근본적인 문제를 가집니다.
    
    - 리소스 배포의 불일치
    - 운영과의 설정 차이
    - 모의 트래픽과 사용자 행위
    - 현업 워크로드와 유사한 요청을 재현하지 못함
    - 모니터링이 빈약함
    - 배포된 데이터 서비스는 운영과 다른 데이터와 부하를 가짐
    
    여러 번 강조하지만 운영 모니터링에 대한 확고한 신뢰를 확보해야 합니다. 운영 시스템을 적절하게 관찰하지 못하면 실패할 확률이 높기 때문입니다. 또한 작은 실험부터 시작하여 실험 자체와 그 영향을 파악하면 신뢰를 얻는 데 도움이 됩니다.
    

## 5.9 파이프라인 구축과 카오스 실험 수행

먼저 깃허브 리포지터리를 포크해 이번 장에서 사용할 개인 리포지터리를 만듭니다. 깃허브 인터페이스를 사용해 포크할 수 있습니다.

- summary
    
    

### 5.9.1 CI 구축

CI에 대해서는 배웠으니, 이제 이전에 복제한 코드를 빌드할 겁니다.

이번 예제에서는 드론을 사용합니다. 먼저 무료 계정으로 회원 가입을 합니다. 그리고 깃허브 계정으로 로그인합니다(드론에 리포지터리를 등록하고 동기화할 수 있습니다). 드론에 로그인했다면 다음으로 포크한 리포지터리를 활성화합니다. 가장 먼저 해야 할 일은 앱을 도커 허브 레지스트리에 푸시하고 쿠버네티스 클러스터에 배포하기 위해 설정에서 시크릿을 추가하는 겁니다.  드론의 리포지터리 아래에서 Setting을 클릭하여 다음 시크릿을 추가합니다

([그림 5-4] 참조).

- docker username
- docker password
- kubernetes server
- kubernetes cert
- kubernetes token

도커 사용자 이름과 비밀번호는 도커 허브에 가입하는 데 사용했던 것과 동일할 겁니다. 다음 단계에서는 쿠버네티스 서비스 계정과 인증을 생성하는 방법, 토큰을 반환하는 방법을 소개합니다.

쿠버네티스 서버를 위해서는 공개된 쿠버네티스 API 엔드포인트가 필요합니다.

- API 엔드포인트 반환

```bash
kubectl cluster-info
```

다음과 같이 출력돼야 합니다. 쿠버네티스 마스터는 [https://kbp.centralus.azmk8s.io](https://kbp.centralus.azmk8s.io/):443에서 실행 중입니다. 이 주소를 kubernetes_server 시크릿에 저장합니다.

드론이 클러스터에 접속할 때 사용할 서비스 계정을 생성합시다. 다음 명령을 이용해 serviceaccount를 생성합니다.

```bash
kubectl create serviceaccount drone
```

다음 명령을 사용해 serviceaccount를 위한 clusterrolebinding을 생성합니다.

```bash
kubectl create clusterrolebinding drone-admin \
--clusterrole=cluster-admin \
--serviceaccount=default:drone
```

다음으로 serviceaccount 토큰을 반환합니다.

```bash
TOKENNAME=`kubectl -n default get serviceaccount/drone -o 
           jsonpath='{.secrets[0].name}'`
TOKEN=kubectl -n default get secret $TOKENNAME -o jsonpath='{.data.token}' | base64 --decode
echo $TOKEN
```

이제 kubernetes_token 시크릿 안에 토큰을 저장합니다.

클러스터 인증을 위해서는 사용자 신원이 필요합니다. 다음 명령을 수행하여 kubernetes_cert를 위해 ca.crt를 붙여넣습니다.

```bash
kubectl get secret $TOKENNAME -o yaml | grep 'ca.crt:'
```

이제 드론 파이프라인에 앱을 빌드하고 도커 허브에 푸시합니다.
처음은 Node.js 프런트엔드를 구축하는 빌드 단계입니다. 이를 위해 드론은 컨테이너 이미지를 이용합니다. 이 기능은 매우 유용합니다. 여기서는 도커 허브의 Node.js 이미지를 사용합니다.

```yaml
pipeline:
  build:
    image: node
    commands:
      -cd frontend
      -npm i redis --save
```

빌드가 완료된 후에는 테스트 단계를 추가합니다. 새롭게 빌드된 앱에 대해 npm을 실행합니다.

```yaml
test:
  image: node
  commands:
    - cd frontend
    - npm i redis --save
    - npm test
```

이제 성공적으로 앱을 빌드하고 테스트했습니다. 다음은 배포 단계입니다. 앱의 도커 이미지를 생성하고 도커 허브에 푸시합니다.

drone.yml 파일을 열어서 다음과 같이 변경합니다.

```yaml
repo: <your-registry>/frontend
publish:
  image:plugins/docker
  dockerfile: ./frontend/Dockerfile
  context: ./frontend
  repo: dstrebel/frontend
  tags: [latest, v2]
  secrets: [ docker_username, docker_password ]
```

도커 빌드 단계가 완료된 후 도커 레지스트리에 이미지가 푸시됩니다.

## 5.9.2 CD 설정

파이프라인의 배포 단계를 위해 쿠버네티스 클러스터에 애플리케이션을 푸시합니다. 리포지터
리의 프런트엔드 앱 폴더 아래의 디플로이먼트 매니페스트를 사용합니다.

```yaml
kubectl:
  image: dstrebel/drone-kubectl-helm
  secrets: [ kubernetes_server, kubernetes_cert, kubernetes_token ]
  kubectl: "apply -f ./frontend/deployment.yaml"
```

파이프라인 배포가 완료된 후 클러스터에서 실행 중인 파드를 확인할 수 있습니다. 다음 명령을 수행하여 파드가 실행 중인지 확인합니다.

```bash
kubectl get pods
```

드론 파이프라인에 다음 단계를 추가해 디플로이먼트 상태를 반환하는 테스트 단계를 추가합니다.

```yaml
test-deployment:
  image: dstrebel/drone-kubectl-helm
  secrets: [ kubernetes_server, kubernetes_cert, kubernetes_token ]
  kubectl: "get deployment frontend"
```

5.9.3 롤링 업그레이드 수행

프런트엔드 코드의 한 줄을 변경해서 롤링 업그레이드를 해봅시다. server.js 파일에서 다음 줄을 수정하고 커밋합니다.

```jsx
console.log('api server is running.');
```

디플로이먼트가 롤아웃되고 기존 파드에 롤링 업데이트되는 것을 볼 수 있습니다. 롤링 업데이트가 완료되면 신규 버전의 애플리케이션이 배포됩니다.

### 5.9.4 간단한 카오스 실험

쿠버네티스 생태계에는 카오스 실험을 수행하는 데 필요한 다양한 도구가 있습니다. 복잡한 서비스형 카오스 솔루션부터 파드를 종료시키는 기본적인 카오스 실험 도구까지 다양합니다. 다음은 대표적인 도구입니다.

- Gremlin
카오스 실험 실행과 관련된 고급 기능을 제공하는 호스팅 카오스 서비스
- Powerfulseal
고급 카오스 시나리오가 포함된 오픈 소스 프로젝트
- 카오스 툴킷
다양한 형태의 카오스 엔지니어링 도구에 무료 공개 커뮤니티 기반의 툴킷 및 API를 제공하는 것을 목표로 하는 오픈 소스 프로젝트
- KubeMonkey
파드의 기본적인 복원력(resiliency) 테스트를 위한 오픈 소스 도구

자동으로 파드를 종료해서 애플리케이션의 탄력성을 테스트할 수 있는 카오스 실험을 간단히 설치해봅시다. 이 실험에서는 카오스 툴킷을 사용합니다.

```bash
pip install -U chaostoolkit
pip install chaostoolkit-kubernetes
export FRONTEND_URL="http://$(kubectl get svc frontend -o
                    jsonpath="[.status. loadBalancer. ingress[*] .ip)") :8880/api/"
chaos run experiment.json
```

## 5.10 CI/CD 모범 사례

- summary
    
    CI/CD 파이프라인이 하루 안에 완벽해질 수는 없습니다. 다음의 모범 사례를 따른다면 파이프라인을 점진적으로 개선해나갈 수 있습니다.
    
    - CI를 이용한 자동화와 빠른 빌드에 집중하세요. 빌드 속도를 최적화한다면 변경된 코드가 실패했을 때 빠른 피드백을 얻을 수 있습니다.
    - 파이프라인에서 안정적으로 테스트하는 데 초점을 두세요. 코드에 문제가 생겼을 때 개발자에게 빠른 피드백을 줄 수 있습니다. 빠른 피드백 반복은 워크플로의 생산성을 향상시킵니다.
    - CI/CD 도구를 결정했다면, 파이프라인을 코드로 정의할 수 있는지 확인하세요. 애플리케이션 코드로 파이프라인 버전 관리를 할 수 있습니다.
    - 이미지 최적화가 되었는지 확인하세요. 이미지 크기를 줄이고, 운영에서 실행할 때 보안상 취약한 지점이 있다면 없애야 합니다. 다단계 도커 빌드를 사용하면 애플리케이션 실행에 불필요한 패키지를 제거할 수 있습니다. 예를 들어 애플리케이션을 빌드할 때는 메이븐이 필요하지만 실제로 이미지를 실행할 때는 필요하지 않습니다.
    - latest 이미지 태그를 사용하지 마세요. BuildID와 깃 커밋을 참조할 수 있는 태그를 사용해야 합니다.
    - CD가 익숙하지 않다면 쿠버네티스 롤링 업그레이드를 사용하세요. 사용하기 쉽고 배포가 편리합니다. CD에 능숙해지고 자신감이 생기면 블루/그린 배포와 카나리 배포 전략을 사용하세요.
    - CD를 이용해 클라이언트 연결과 데이터베이스 스키마가 어떻게 업그레이드되며 애플리케이션에서 어떻게 처리되는지를 꼭 테스트하세요.
    - 운영 테스트는 애플리케이션의 안정성에 도움을 줍니다. 훌륭한 모니터링이 가동 중인지 확인하세요. 또한 소규모로 시작하고 실험의 폭발 반경을 제한하세요.

마치며..
이번 장에서는 소프트웨이의 안정적인 전달을 지원하는 CI/CD 파이프라인을 구축하는 단계
에 대해 설명했습니다. CI/CD 파이프라인은 쿠비네티스에 애플리케이선을 전달할 때 위험을
줄이고 치리 속도를 높이는 데 도움이 됩니다. 또한 애플리케이션을 배포할 때 활용할 수 있는
다양한 배포 전락에 대해서도 다뤘습니다.