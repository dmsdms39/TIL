**이 장의 주제**

쿠버네티스에 애플리케이션 배포를 위한 CI/CD 파이프라인 구축 방법

- **주요 단계**
    1. 버전 관리
    2. CI
    3. 테스트
    4. 이미지 태깅
    5. CD
    6. 배포 전략
    7. 배포 테스트
    8. 카오스 실험
    - **파이프라인 예제**
        1. 깃 리포지터리에 코드 변경 사항 푸시
        2. 애플리케이션 코드 빌드
        3. 코드 테스트
        4. 테스트 성공 시 컨테이너 이미지 빌드
        5. 이미지 컨테이너 레지스트리에 푸시
        6. 쿠버네티스에 애플리케이션 배포
        7. 배포 애플리케이션 테스트
        8. 디플로이먼트 롤링 업그레이드 실행

**목표**

- 배포 자동화를 통한 안정성과 속도 향상
- 수동 배포 오류 및 설정 표류 문제 해결해 자동화 프로세스 구현

## 5.1 버전 관리

- summary : 애플리케이션 실행 이력과 설정 코드 변경을 관리하는 버전 관리가 필요하다. 쿠버네티스 매니페스트 또는 헬름 차트가 이들을 포함한다.
    - 이는 소통과 협업의 데브옵스 원칙을 정립하는 데 도움
    - 기능과 개발을 위한 브랜치도 별도로 존재 → 마스터 브랜치로 병합
    - 브랜치 전략을 세우는 방법(조직 구조와 업무에 따라 다름)
    - 쿠버네티스 매니페스트 또는 헬름 차트에는 애플리케이션 코드와 설정 코드가 모두 포함
    - 애플리케이션 개발자와 운영 엔지니어가 단일 스토리지에서 공동의 작업을 수행하는 경우, 애플리케이션을 운영에 전달하는 팀에 대한 신뢰도 향상

## 5.2 지속적 통합

- summary : CI는 코드 변경을 버전 관리 리포지터리에 지속적으로 통합하는 과정이다. 대표적인 제품으로는 Jenkins가 있다.
    - CI는 코드 변경을 버전 관리 리포지터리에 지속적으로 통합하는 과정
    - 커밋할 때는 큰 코드 변경을 가끔씩 하는 것보다 작은 코드 변경을 자주 하는 것이 나음
    - 커밋될 때마다 빌드가 실행
    - 문제가 발생했을 때 빠른 피드백
    - 운영 팀 역시 애플리케이션 코드와 소프트웨어 개발 워크플로를 알아감
    - CI의 대표적인 제품으로는 Jenkins가 있음

## 5.3 테스트

- summary : 파이프라인에서 테스트를 실행하는 이유는 코드 변경으로 빌드가 실패할 때 빠르게 피드백을 받기 위해서이다. 인프라와 애플리케이션의 자동 운영과 배포를 위해 모든 코드베이스를 자동으로 테스트하는 방안을 찾아야 한다.
    - 테스트 실행 이유: 코드 변경 시 빌드 실패를 빠르게 피드백
    - 테스트 프레임워크: 사용 언어에 따라 결정 (예: Go는 `go test`).
    - 폭넓은 테스트 집합으로 나쁜 코드 배포 방지, 빌드 실패 시 이미지 푸시 방지.
    - 개발자와 테스트: 자동화된 테스트는 인프라와 애플리케이션 운영 및 배포에 필수.
    - 헬름 도구 활용: `helm lint`로 애플리케이션 패키지 테스트.
    - 파이프라인 내 테스트: 단위 테스트(개발자 책임), 스모크 테스트(협력 필요) 등 다양한 테스트.
    

## 5.4 컨테이너 빌드

이미지 빌드시 이미지가 작을수록 속도와 보안 면에서 장점을 가집니다. 작은 이미지를 위한 빌드 방법에는 세가지 전략이 있습니다. 하지만 각 전략에는 트레이드 오프가 존재합니다.

1. **다중 단계 빌드**
    - 애플리케이션 실행에 불필요한 의존성을 제거해 최적화된 이미지를 생성
    - 정적 바이너리만 포함하는 이미지를 하나의 Dockerfile로 최적의 이미지 빌드 가능
2. **배포판이 없는 기본 이미지**
    - 불필요한 바이너리와 shell 제거로 이미지 크기 감소와 보안 강화
    - 단, shell과 디버깅 도구가 없으므로 디버깅에 어려움이 있음
3. **최적화된 기반 이미지**
    - OS 계층에서 불필요한 요소를 제거한 가벼운 이미지 사용. 예: Alpine Linux(10MB)나 Debian
    - 이미지 최적화는 컨테이너 효율성과 보안 위험도 낮추는 역할을 함

## 5.5 컨테이너 이미지 태그

**Docker 이미지 빌드 및 태그 전략**

- CI 파이프라인에서 도커 이미지를 빌드하고 배포 시, 배포 이미지의 버전을 명확히 구분할 태그 전략이 필요
- `latest` 태그 사용 지양 : 버전이 없어 코드 변경 이력을 파악하기 어려움
- 고유 태그 필수 : 코드 변경 및 빌드를 추적

**적절한 전략을 통해 코드 변경 및 빌드 이력을 쉽게 관리**

- 태그 전략
    1. **BuildID**
        - CI 빌드 시 생성된 BuildID를 태그에 사용해 이미지의 빌드 출처 파악 가능.
    2. **빌드 시스템-BuildID**
        - 여러 빌드 시스템을 구분하기 위해 BuildID에 빌드 시스템 정보 추가.
    3. **깃 해시** 
        - 커밋 시 생성된 깃 해시를 태그에 포함해 생성된 커밋 정보 확인 가능.
    4. **깃 해시-BuildID** 
        - 커밋과 BuildID를 조합해 상세한 이미지 출처 제공
        - 긴 태그 길이에 주의 필요.

## 5.6 지속적 배포

**CD는 변경 사항을 자동으로 운영에 배포**

- 컨테이너 이미지가 개발, 스테이지, 운영으로 옮겨갈 수 있도록 불변 객체가 된다.
- CD에 집중하기 전에 먼저 견고한 CI 파이프라인을 구축 필요
- 초기에 견고한 테스트 집합을 갖춰야 잘못된 롤아웃을 막는다.
- 스테이지에서 잘 동작하던 디플로이먼트가 운영으로 넘어간 후 **설정 표류 때문에** 배포에 실패하는 경우가 많다.

## 5.7 배포 전략

**애플리케이션의 새로운 버전을 롤아웃하기 위한 전략**

- 롤링 업데이트
    - 현재 실행 중인 애플리케이션을 다운타임 없이 업데이트 가능(현재 frontend:v1 → v2)
- 블루/그린 배포
    - 트래픽이 새로운 환경으로 전환되는 시점을 조절할 수 있으므로 새 버전의 애플리케이션 롤아웃을 효과적으로 통제
- 카나리 배포
    - 일부 사용자에게만 새로운 기능을 테스트 가능
    - 문제가 없다면 더 많은 트래픽 비율을 새로운 애플리케이션으로 이동

| **특징** | **롤링 업데이트** | **블루/그린 배포** | **카나리 배포** |
| --- | --- | --- | --- |
| **배포 방식** | 기존 버전과 새로운 버전이 점진적으로 교체 | 새로운 버전(그린)을 전체에 배포하고, 기존 버전(블루)을 종료 | 일부 사용자에게만 새로운 버전을 배포, 점진적으로 확대 |
| **트래픽 처리** | 점진적으로 새로운 버전으로 트래픽을 전환 | 새로운 버전으로 트래픽을 전체 전환 | 일부 사용자만 새로운 버전으로 전환 |
| **장점** | 다운타임이 없음, 점진적인 배포 | 롤백이 쉬움, 새로운 버전이 준비되면 전체 배포 | 새로운 버전의 안정성을 검증 가능 |
| **단점** | 트래픽이 새/구 버전으로 나뉠 수 있음 | 배포 후 트래픽 전환 시 일시적인 다운타임 가능 | 초기 사용자에게만 배포되므로 피드백 반영에 시간 소요 |
| **롤백** | 배포 중에 오류 발생 시 빠르게 롤백 가능 | 블루에서 그린으로 전환 후 롤백 용이 | 카나리 배포의 비율을 조정하거나 초기 상태로 롤백 가능 |
| **적합한 상황** | 버전 업그레이드가 점진적으로 필요한 경우 | 두 버전의 안정성을 동시에 유지해야 할 때 | 빠르게 새로운 버전을 테스트하고자 할 때 |
| **배포 속도** | 점진적이므로 상대적으로 느림 | 빠르게 전체 트래픽을 새로운 버전으로 전환 | 초기 소수에게 배포하고 점진적으로 확대 가능 |
- 상세
    
    쿠버네티스에 내장되어 있는 롤링 업데이트를 사용하면 현재 실행 중인 애플리케이션을 다운타임 없이 업데이트할 수 있습니다. 예를 들어 현재 frontend:v1으로 실행 중인 프런트엔드 앱을 frontend:v2로 업데이트한 경우 쿠버네티스는 롤링 방식으로 레플리카를 frontend:v2로 업데이트합니다. 
    
    ![20241126_180219_284.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/bf8b5dbc-826d-4e7f-8b31-80262575587f/a431dba4-f1f2-4f4d-b9d1-e41c4a115f4c/20241126_180219_284.jpg)
    
    디플로이먼트 객체를 사용하면 한 번에 업데이트할 최대 레플리카 수와 사용할 수 없는 최대 파드 수를 롤아웃 과정에서 설정할 수 있습니다. 다음 매니페스트는 롤링 업데이트 전략을 설정하는 방법의 예입니다.
    
    ```yaml
    kind: Deployment
    apiVersion: v1
    metadata:
      name: frontend
    spec:
      replicas: 3
      template:
        spec:
          containers:
          - name: frontend
            image: brendanburns/frontend:v1
      strategy:
        type: RollingUpdate
        rollingUpdate:
          maxSurge: 1 # 한 번에 업데이트할 최대 레플리카 수
          maxUnavailable: 1 # 롤아웃 중간에 가용하지 않는 최대 레플리카 수
    ```
    
    롤링 업데이트를 사용하면 클라이언트와의 연결이 끊어질 수 있으므로 주의해야 합니다. 이를 해결하기 위해 준비성 프로브(Readiness Probe)와 preStop 라이프사이클 훅을 사용할 수 있습니다. 준비성 프로브는 배포된 새로운 버전이 트래픽을 수용할 준비가 되었는지 확인하고 preStop 훅은 현재 배포된 애플리케이션의 커넥션을 드레인합니다. 이 훅은 컨테이너가 종료되기 전에 동기 방식으로 호출되므로 마지막 종료 신호를 받기 전에 완료되어야만 합니다. 다음 예제는 준비성 프로브와 라이프사이클 훅을 구현한 예입니다.
    
    ```yaml
    kind: Deployment
    apiversion: V1
    metadata:
      name: frontend
    spec:
      replicas: 3
      template:
        spec:
          containers:
          - name: frontend
            image: brendanburns/frontend:v1
            livenessprobe:
              # ...
            readinessprobe:
              httpGet:
                path: /readiness # 프로브 엔드포인트
                port: 8888
            lifecycle:
              prestop:
                exec:
                  command: ["/usr/sbin/nginx", "-s", "quit"]
      strategy:
        # ...
    ```
    
    이 예제에서 preStop 라이프사이클 훅은 정상적으로 NGINX를 종료하는 반면, SIGTERM은 빠르게 강제 종료 작업을 수행합니다.
    
    롤링 업데이트의 또 다른 문제는 롤오버 중간에 두 가지 버전의 애플리케이션이 동시에 실행된다는 것입니다. 따라서 데이터베이스 스키마는 애플리케이션의 두 가지 버전 모두를 지원해야 합니다. 여기서 스키마에 새로운 버전에 필요한 컬럼을 추가하는 기능 플래그 전략을 사용할 수도 있습니다. 롤링 업데이트가 완료된 이후에는 불필요한 컬럼을 삭제할 수 있습니다.
    
    또한 우리는 디플로이먼트 매니페스트에 준비성과 생명성 프로브를 정의했습니다. 준비성 프로브는 엔드포인트인 서비스 뒤에 트래픽을 배치하기 전에 애플리케이션이 트래픽을 지원할 준비가 되었는지를 확인합니다. 생명성 프로브는 애플리케이션이 정상적으로 실행 중인지 확인하며 만약 생명성 프로브에 실패할 경우 파드를 재시작합니다. 쿠버네티스는 오류 때문에 파드가 종료되었을 때만 자동으로 재시작합니다. 데드락에 걸려 종료되지 않은 파드도 생명성 프로브를 이용하여 엔드포인트를 점검하고 재시작할 수 있습니다.
    
    블루/그린 배포를 사용해 예측 가능한 방식으로 애플리케이션을 릴리스할 수 있습니다. 블루/그린 배포는 트래픽이 새로운 환경으로 전환되는 시점을 조절할 수 있으므로 새 버전의 애플리케이션 롤아웃을 효과적으로 통제할 수 있습니다. 대신 기존 환경과 새로운 환경을 동시에 배포할 만큼 충분한 용량이 필요합니다. 이 유형의 배포는 이전 버전으로 쉽게 전환되는 등 많은 장점을 가집니다. 그렇지만 몇 가지 주의할 사항이 있습니다.
    
    - 데이터베이스 마이그레이션이 어려울 수 있습니다. 진행 중인 트랜잭션과 스키마 업데이트의 호환성을 고려해야 하기 때문입니다.
    - 두 환경을 우연히 삭제할 위험이 있습니다.
    - 두 환경을 위한 추가적인 용량이 필요합니다.
    - 하이브리드 배포의 경우 레거시 앱에서 발생하는 문제를 해결해야 합니다.
    
    [그림 5-2]는 블루/그린 배포를 보여줍니다.
    
    ![20241126_180253_351.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/bf8b5dbc-826d-4e7f-8b31-80262575587f/b439056d-5280-460e-a1b2-7dbd84ed804b/20241126_180253_351.jpg)
    
    카나리 배포는 블루/그린 배포와 상당히 유사하지만 신규 배포로 트래픽을 전환하는 것에 대해 다양한 통제권을 제공합니다. 최신 인그레스 구현은 신규 배포로 전달할 트래픽의 비율을 정할 수 있는 기능이 있습니다. 배포 전략 구현에 필요한 여러 기능을 제공하는 이스티오, 링커드, 해시코프의 콘술과 같은 서비스 메시(Service Mesh) 기술을 구현할 수 있습니다.
    
    카나리 배포에서는 일부 사용자에게만 새로운 기능을 테스트할 수도 있습니다. 예를 들어 새로운 버전의 애플리케이션을 전체 사용자의 10%에게만 우선 롤아웃해서 테스트할 수 있습니다. 적은 수의 사용자에게만 먼저 노출하여, 잘못 배포하거나 기능이 동작하지 않는 위험성을 줄이는 것입니다. 
    
    문제가 없다면 더 많은 트래픽 비율을 새로운 애플리케이션으로 이동시킵니다. 특정 리전의 사용자나 특정 프로필을 가진 사용자만을 대상으로 카나리 배포를 할 수 있는 고급 기술도 있습니다. 사용자는 새로운 기능을 테스트하고 있다는 것을 모르기 때문에 이러한 배포를 흔히 A/B 또는 다크 릴리스(Dark Release)라고 부릅니다.
    
    카나리 배포에는 블루/ 그린 배포의 주의 사항을 포함하여 아래와 같은 추가 고려 사항이 있습니다. 
    
    - 일부 사용자에게만 트래픽을 전환하는 기능
    - 신규 배포 상태와 비교하기 위한 안정된 상태에 대한 확고한 지식
    - 신규 배포가 '좋은'또는 '나쁜' 상태인지 알 수 있는 매트릭
    
    [그림 5-3]은 카나리 배포의 예시입니다.
    
    ![20241126_180258_560.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/bf8b5dbc-826d-4e7f-8b31-80262575587f/081b70aa-6421-4ec6-a3ed-3f722f333c83/20241126_180258_560.jpg)
    
    NOTE_카나리 배포는 동시에 여러 버전의 애플리케이션을 실행할 때 어려움을 겪습니다. 예를 들어 데이터베이스 스키마는 두 버전의 애플리케이션을 동시에 지원해야 합니다. 그래서 이 전락을 사용할 때는 의존된 서비스를 다루는 방법과 여러 버전을 실행하는 법을 제대로 파악해야 합니다. 이는 견고한 AP 계약을 체결하고 데이터 서비스가 동시에 배포된 여러 비전을 지원하도록 보장하는 것을 포함합니다.
    

## 5.8 운영에서 테스트

- summary
    
    **운영 환경 테스트**
    
    - 탄력성, 확장성, UX에 대한 신뢰도 향상
    - 도전적이고 위험하지만 안정성을 위한 가치
    
    **운영 테스트 고려 사항**
    
    - 운영 테스트의 효과를 파악하기 위한 심층적인 관찰 전략 마련
        1. UX에 영향을 미치는 메트릭을 관찰
        2. 시스템 복원력을 향상시키는 명확한 지표 
    - 시스템 구성한 점으로부터의 자동 복구를 위한 높은 수준의 **자동화 필요**
    - **위험 최소화 및 효과적 테스트 도구**
        - 분산 추적(Distributed Tracing)
        - 인스트루멘테이션(Instrumentation)
        - 카오스 엔지니어링(Chaos Engineering)
        - 트래픽 섀도잉(Traffic Shadow)
        - 카나리 배포
        - A/B 테스트
        - 트래픽 전환
        - 기능 플래그
    - **실험 가설 검증 과정**
        
        실제 생산 시스템에 실험을 배치해 그 시스템 내의 취약점을 발견하는 것. 통제된 실험 환경에서 시스템의 동작을 관찰 및 파악.
        
        - 가설을 세우고 안정된 상태를 파악합니다.
        - 시스템에 영향을 미치는 현업의 다양한 이벤트를 모읍니다.
        - 통제 그룹을 구축하고 안정된 상태와 비교하는 실험을 합니다.
        - 실험을 수행해 가설을 검증합니다.
        - 실험을 수행할 때 폭발 반경(blast radius : 생길 수 있는 문제)의 범위를 최소화
    - **스테이지에서 테스트 문제점**
        - 리소스 배포의 불일치
        - 운영과의 설정 차이
        - 모의 트래픽과 사용자 행위
        - 현업 워크로드와 유사한 요청을 재현하지 못함
        - 모니터링이 빈약함
        - 배포된 데이터 서비스는 운영과 다른 데이터와 부하를 가짐
    - 운영 모니터링에 대한 확고한 신뢰 확보

## 5.9 파이프라인 구축과 카오스 실험 수행

### 5.9.1 CI 구축

가장 먼저, 앱을 도커 허브 레지스트리에 푸시하고 쿠버네티스 클러스터에 배포하기 위해 설정에서 시크릿을 추가

- docker username
- docker password
- kubernetes server
- kubernetes cert
- kubernetes token

다음 단계 쿠버네티스 서비스 계정과 인증을 생성하는 방법, 토큰을 반환하는 방법

쿠버네티스 서버를 위해 공개된 쿠버네티스 API 엔드포인트

- API 엔드포인트 반환

```bash
kubectl cluster-info
```

쿠버네티스 마스터는 [https://kbp.centralus.azmk8s.io](https://kbp.centralus.azmk8s.io/):443에서 실행  주소를 kubernetes_server 시크릿에 저장

드론이 클러스터에 접속할 때 사용할 서비스 계정을 생성

- serviceaccount를 생성

```bash
kubectl create serviceaccount drone
```

- serviceaccount를 위한 clusterrolebinding을 생성

```bash
kubectl create clusterrolebinding drone-admin \
--clusterrole=cluster-admin \
--serviceaccount=default:drone
```

- serviceaccount 토큰을 반환

```bash
TOKENNAME=`kubectl -n default get serviceaccount/drone -o 
           jsonpath='{.secrets[0].name}'`
TOKEN=kubectl -n default get secret $TOKENNAME -o jsonpath='{.data.token}' | base64 --decode
echo $TOKEN
```

 kubernetes_token 시크릿 안에 토큰을 저장

클러스터 인증을 위해서는 사용자 신원이 필요

- kubernetes_cert를 위해 ca.crt 인증서 정보 출력

```bash
kubectl get secret $TOKENNAME -o yaml | grep 'ca.crt:'
```

드론 파이프라인에 앱을 빌드, 도커 허브에 푸시

Node.js 프론트엔드를 구축하는 **빌드 단계**

- 드론은 컨테이너 이미지(도커 허브의 Node.js 이미지) 사용

```yaml
pipeline:
  build:
    image: node
    commands:
      -cd frontend
      -npm i redis --save
```

빌드가 완료된 후 테스트 단계를 추가

- 새롭게 빌드된 앱을 npm 실행

```yaml
test:
  image: node
  commands:
    - cd frontend
    - npm i redis --save
    - npm test
```

배포 단계 : 앱의 도커 이미지를 생성, 도커 허브 푸시

- drone.yml 파일

```yaml
repo: <your-registry>/frontend
publish:
  image:plugins/docker
  dockerfile: ./frontend/Dockerfile
  context: ./frontend
  repo: dstrebel/frontend
  tags: [latest, v2]
  secrets: [ docker_username, docker_password ]
```

도커 빌드 단계 완료 후 도커 레지스트리에 이미지 푸시

### 5.9.2 CD 설정

파이프라인의 배포 : 쿠버네티스 클러스터에 애플리케이션을 푸시

- 리포지터리의 프론트엔드 앱 폴더 아래의 디플로이먼트 매니페스트

```yaml
kubectl:
  image: dstrebel/drone-kubectl-helm
  secrets: [ kubernetes_server, kubernetes_cert, kubernetes_token ]
  kubectl: "apply -f ./frontend/deployment.yaml"
```

- 클러스터에서 실행 중인 파드 확인

```bash
kubectl get pods
```

- 드론 파이프라인에 디플로이먼트 상태 반환 테스트 단계 추가

```yaml
test-deployment:
  image: dstrebel/drone-kubectl-helm
  secrets: [ kubernetes_server, kubernetes_cert, kubernetes_token ]
  kubectl: "get deployment frontend"
```

### 5.9.3 롤링 업그레이드 수행

프론트엔드 코드의 한 줄을 변경 (server.js 파일)

```jsx
console.log('api server is running.');
```

→ deployment가 롤아웃되고 기존 파드 롤링 업데이트

→ 롤링 업데이트가 완료 후 신규 버전의 애플리케이션 배포

### 5.9.4 간단한 카오스 실험

복잡한 서비스형 카오스 솔루션부터 파드를 종료시키는 기본적인 카오스 실험 도구

- 대표적인 도구
    - Gremlin
    카오스 실험 실행과 관련된 고급 기능을 제공하는 호스팅 카오스 서비스
    - PowerfulSeal
    고급 카오스 시나리오가 포함된 오픈 소스 프로젝트
    - 카오스 툴킷
    다양한 형태의 카오스 엔지니어링 도구에 무료 공개 커뮤니티 기반의 툴킷 및 API를 제공하는 것을 목표로 하는 오픈 소스 프로젝트
    - KubeMonkey
    파드의 기본적인 복원력(resiliency) 테스트를 위한 오픈 소스 도구

자동으로 파드를 종료해 애플리케이션의 탄력성을 테스트하는 카오스 실험을 간단히 설치.

```bash
pip install -U chaostoolkit
pip install chaostoolkit-kubernetes
export FRONTEND_URL="http://$(kubectl get svc frontend -o
                    jsonpath="[.status. loadBalancer. ingress[*] .ip)") :8880/api/"
chaos run experiment.json
```

## 5.10 CI/CD 모범 사례

1. CI를 이용한 자동화와 빠른 빌드 속도
    
    : 변경된 코드가 실패했을 때 빠른 피드백
    
2. 파이프라인에서 안정적인 테스트
    
    : 코드에 문제가 생겼을 때 개발자에게 빠른 피드백으로 워크플로의 생산성을 향상
    
3. 애플리케이션 코드로 파이프라인 버전 관리
4. 이미지 최적화 & 운영에서 실행할 때 다단계 도커 빌드를 사용해 애플리케이션 실행에 불필요한 패키지를 제거 
5. Latest 이미지 태그가 아닌 BuildID와 깃 커밋 참조 가능한 태그 사용
6. CD 초보 사용자 : 쿠버네티스 롤링 업그레이드 (사용이 쉽고 배포가 편리)
    
    CD 중급 사용자 : 블루/그린 배포, 카나리 배포
    
7. CD를 이용해 아래 항목 테스트 필요
: 클라이언트 연결 업그레이드, 데이터베이스 스키마 업그레이드, 애플리케이션 처리 방식
8. 운영 테스트와 모니터링으로 애플리케이션 안정성 확보하고 소규모로 시작

이 장을 마치며..

- 소프트웨어의 안정적인 전달을 지원하는 CI/CD 파이프라인의 구축 단계
- CI/CD 파이프라인은 쿠버네티스에 애플리케이션 전달시 위험을 줄이고 처리 속도 향상
- 애플리케이션의 다양한 배포 전략